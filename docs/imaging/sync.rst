.. _Imaging Sync:

======================================
Imaging: Synchronisation
======================================

The two-photon miniscopes make use of multiple independent time series data streams - imaging, tracking, running wheel etc. **Synchronisation** is the process of converging all of those separate time-series data, which may be derived from independent, unique, clocks that do not fully agree with one another, into a single temporal frame of reference.

The *outcome* of that synchronisation stage should more properly be called time information, but throughout the Imaging pipeline is often *also* called synchronisation data. 

Three methods are currently in use within the Moser group:

* `Wavesurfer <http://wavesurfer.janelia.org/>`_ with a National Instruments GPIO card
* Femtonics Mesc synchronisation
* ScanImage Presynchronisation

Each of these implementation is then inserted into a very generalised schema, which maps the time data from each time series into a single temporal frame of reference. This generalised approach has both benefits and drawbacks: the primary benefit is that it can be extended to new types of data - and new hardware - very easily. The primary drawback is that it adds complexity and overhead to common operations, and that the users need to be aware of that complexity. 

Synchronisation data is stored in the ``Sync`` table and its sub-tables. 

.. figure:: /_static/imaging/sync/sync_tables.PNG
   :alt: Synchronisation section of the imaging schema

Each Session is generated by a **Setup** (:ref:`Imaging Terminology Setup`), which is tracked in the ``Setup`` table. Each entry in the ``Setup`` table has a list of the types of synchronisation data (and how to interpret it) that might be generated in the table ``Setup.Sync``.::

  Setup.Sync & {"setup_name":"Mini Blue", "setup_timestamp":"2020-08-20 00:00:00"}

.. figure:: /_static/imaging/sync/setup-sync-table.png
   :alt: Contents of the ``Setup.Sync`` table


When a new Session is ingested, the synchronisation data is inserted into the ``Sync`` table and its part tables. Each Session has one (or more) entries in the ``Sync`` table, corresponding to a single time series, from a single instrument, with each time series being identified by a ``sync_name``.

The actual timestamps themselves are stored in the column ``sync_data`` of the ``Sync`` table. The values are stored in *samples*. The sample rate (samples per second) is also stored, in column ``sample_rate``, if you wish to convert into time periods in seconds. 


Sync Names and Generic Names
--------------------------------

The ``Setup.Sync`` entries have two related attributes:

* ``sync_name``
* ``generic_name``

The most important attribute here is the ``generic_name``. This defines how further downstream tables identfy *which* Sync stream they should be looking for, to pair time-series data with its timestamps. The main ``generic_names`` are as follows:

* ``frames_imaging`` : timestamps for two-photon imaging frames
* ``tracking_rotary`` : timestamps of 1-dimensional, wheel-encoder data
* ``Tracking2LED`` : timestamps of video frames of open-field tracking, where the subject is identified by a pair of head-mounted LEDs
* ``TrackingDLC`` : timestamps of video frames intended to be analysed with DLC (see :ref:`Imaging dlc`).

``sync_name`` is intended to provide a name that conveys more information to the users.


In most cases, users should not need to extract data from the ``Sync`` tables directly: timestamp information is inserted into the more common tables (``Tracking.Linear``, ``Tracking.OpenField``, ``SignalTracking``).

The following example is a simplifed approach to fetching Synchronisation data either where it is not already present, or where the user may need to apply some processing to it first.

.. code-block:: python
    
    # Use an arbitrary key to the `Cell.Traces` table
    key = {"session_name":"d6ba671faad74695", "cell_id":3, "channel":"primary"}
    df_f = (Cell.Traces & key).fetch1("df_f")

    # Identify what Setup was in use
    setup = (Session * MetaSession.Setup & key).fetch1()

    # Identify what sync name we should be looking for
    generic_name = "frames_imaging" # cell.Traces data -> it's from the 2p data
    sync_name = (Setup.Sync & setup & {"generic_name":generic_name}).fetch1("sync_name")

    # Get the sync data and sampling rate, and convert from samples to seconds
    sync_data_samples, fs = (Sync & key & {"sync_name":sync_name}).fetch1("sync_data", "sample_rate")
    sync_data_s = sync_data_samples / fs

    # Plot the resulting data
    fig, ax = plt.subplots()
    ax.plot(sync_data_s, df_f)
    ax.set_ylabel("df/f")
    ax.set_xlabel("time (s)")

.. figure:: /_static/imaging/sync/extracted_sync_data.png
   :alt: Contents of the ``Setup.Sync`` table

Wavesurfer sync
----------------------

Multiple independent instruments acquire data at their own sampling frequency, whatever that is. Each time a sample is taken, that instrument outputs a TTL pulse. A single GPIO device recieves those signals, with a single channel dedicated to each device. The timestamps (and sampling frequencies) for each of those devices is determined by the GPIO device's own clock, thus providing a single temporal frame of reference (customarily called a "master clock".

At present, this uses `Wavesurfer <http://wavesurfer.janelia.org/>`_ software running on a computer with a National Instruments GPIO card, but the method is generalisable to any GPIO device and associated software to interface with it. 

Below is an example of the raw recording of 3 sync streams (digital inputs) via wavesurfer. After an initial delay, the acquisition is triggered and the scanning starts (*2P frames*, master). At the same time the camera for tracking of 2 LEDs is triggered and every exposure is registered (*Tracking frames*). The (*Wheel*) stream records serial events that are sent from a microcontroller that is registering data from a rotary encoder attached to a running wheel (irregular since script wasn't running). 

.. figure:: /_static/imaging/sync/wavesurfer_sync_example.png
   :alt: Synchronisation of parallel data streams

Events are extracted according to the polarity of the digital signal - i.e. rising or falling edge - and shown on the image below as red bars. A *last_index_master* is inferred (since not actually recorded) and the other sync streams are cut accordingly. To concatenate multiple (sub-)sessions, sync streams are zeroed on master (*first_index_master*)  and every subsequent sync stream is concatenated to the previous one adding 1 to *last_index_master*.

.. figure:: /_static/imaging/sync/wavesurfer_sync-01.jpg
   :alt: Synchronisation of parallel data streams

Wavesurfer stores its data in an ``hdf5`` container. A reader for these containers is provided under `/helpers/mini2p_wavesurfer.py <https://github.com/kavli-ntnu/dj-moser-imaging/blob/master/helpers/mini2p_wavesurfer.py>`_. 

Scanimage sync
---------------------

The OpenMiniscope system implements one particular special case of the more general synchronisation scheme outlined above. Data can be *pre-synchronised* with the `ScanImage <http://scanimage.vidriotechnologies.com/display/SIH/ScanImage+Home>`_ software. In this case, instead of each instrument operating at its own sampling frequency determined by its own independent clock, each frame of acquisition is triggered by a signal sent from a single "master" source, which is the device controlling the two-photon imaging acquisition. Each time that ScanImage triggers a frame of two-photon imaging data, it can send a trigger signal to other instruments, causing them to acquire a frame of data simultaneously, or at least with a known, constant, offset. 

In this case, the timestamp data for two-photon imaging frames is identical to the timestamp data for tracking frames.

Note that although this method is superficially much simpler than the more general case, it has its own complexities, especially where multi-plane two-photon imaging is in use. In general, the design of the OpenMiniscope system is to send one trigger to external instruments on each *volume* acquisition, rather than on each *plane* acquisition, and consequently, there may be an integer multiple between the number of plane acquisitions and the nnumber of tracking frames. 

For instruments where the acquisition rate of the two-photon imaging frames is too slow, the system supports acquiring a limited number of data streams at the acquisition rate of the two-photon photodetectors. In this case, a much higher temporal resolution can be saved as an "imaging frame", generating a TIF image (essentially, an overengineered array of data) alongisde the imaging data.
    

Femtonics Sync
---------------

For the femtonics setup (.mesc files), the internal oscilloscope function is used to record events in sync with acquisition (see `/helpers/femto_mesc.py <https://github.com/kavli-ntnu/dj-moser-imaging/blob/master/helpers/femto_mesc.py>`_).

